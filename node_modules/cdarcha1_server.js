"use strict";
// ====================== CONFIG.TS ===================
exports.__esModule = true;
var apiVersion = "0.2";
// url na backend
//const urlMain: string = "192.168.1.11" //local
var urlMain = "cdarcha.mzk.cz"; //server
var urlPart = "/";
var apiImport = "api/import";
var urlUpload = "file/upload";
var urlCoverUpload = "file/coverupload";
var apiChecksum = "api/gethash";
var apiGetMedia = "api/getmedia";
var apiGetAllMediaList = "api/getallmedialist";
var apiCloseArchive = "api/closearchive";
var urlMetadata = "api/media";
var urlCoverFile = "file/cover";
var urlCoverApi = "api/cover";
var urlMasterFile = "file/master";
var urlWeb = "cdarcha";
var urlParams = "?books=";
var urlStorage = "storage/";
var urlTocFile = "file/toc";
var urlTocApiThumbnail = "api/toc/thumbnail";
var urlTocApiPdf = "api/toc/pdf";
var uriPartTocThumbnail = "/thumbnail";
var uriPartTocPdf = "/pdf";
var uriAlive = "runtime/alive";
// kolekce s metadaty tak jak je pojmenovana v mongodb
var metaCollection = "biblio";
var archiveCollection = "archive";
var mediaCollection = "media";
var filesCollection = "files";
var usersCollection = "users";
// timeout dotazu na backend (ms)
var timeout = 20 * 1000; // zmena po prechodu na reverznu proxy na BE (stava se ze requesty expiruji; toto je docasne reseni)
//const timeout: number = 5 * 1000;
// doba, po ktere se opet zkusime doptat backendu po timeoutu (ms)
var timeOutDuration = 1 * 1000; // zmena po prechodu na reverznu proxy na BE (stava se ze requesty expiruji; toto je docasne reseni)
//const timeOutDuration: number = 1000 * 1000;
// doba, po ktere se opet pokusime stahnout nahled, pokud ho backend nemel (ms)
var timeNotfound = 86400 * 1000;
// adresar s TOC dokumenty
var tocFileDir = "/home/users/okcz/static/toc/";
// temporary files
//const tmpFolder: string = "/home/lubo/workspace/cdarcha_server/tmp";
//const storageFolder: string = "/home/lubo/workspace/cdarcha_server/store";
var tmpFolder = "/home/cdarcha/cdarcha/tmp";
var storageFolder = "/mnt/cdarcha";
// =========================================
var request = require('request');
var toEan = require('to-ean').toEan;
var URL_lib = require('url');
var fs = require('fs');
var md5 = require('MD5');
var http = require('http');
var mongo = require('mongodb');
var crypto = require('crypto');
var bcrypt = require('bcrypt-nodejs');
var httpProxy = require('http-proxy');
var multipart = require('parse-multipart');
var partParser = require('book-part-parser');
var xmlFormatter = require('xml-formatter');
var proxy = httpProxy.createProxyServer();
var etags = {}; // obsahuje vsechny platne etag pro cache prohlizec
var Bibinfo_1 = require("./Bibinfo");
var Archive_1 = require("./Archive");
var Media_1 = require("./Media");
var Files_1 = require("./Files");
var Statistics_1 = require("./Statistics");
var Permissions_1 = require("./Permissions");
var Helpers_1 = require("./Helpers");
// ====================== CD ARCHA VERSION 1 ===================
var server = function (req, response, db) {
    var a = new Server(req, response, db);
    a.go(a);
};
var Server = /** @class */ (function () {
    function Server(req, response, db) {
        this.requrl = req.url;
        testLog("43", "CD ARCHA v1 starting...");
        testLog("92", "Request url:" + this.requrl);
        // console.log(req.connection.remoteAddress);
        // console.log(requrl);
        this.query = URL_lib.parse(this.requrl, true).query;
        // console.log('query: ' + JSON.stringify(query));
        this.date = new Date();
        this.timestamp = this.date.toISOString();
        this.now = this.date.getTime();
        // console.log(timestamp);
        // console.log('HEAENCRYPTD: ' + JSON.stringify(req.headers));
        this.etag = req.headers['if-none-match'] || req.headers['Etag'];
        this.referer = req.headers['referer'];
        this.remoteIP = req.connection.remoteAddress;
        this.encsigla = this.query.encsigla;
        // console.log(etags);
        // console.log('index: ' + requrl.indexOf(urlMetadata));
        this.req = req;
        this.response = response;
        this.db = db;
        this.sigla = Permissions_1.Permissions.refererValid(this.referer, this.remoteIP, this.encsigla);
    }
    Server.prototype.go = function (s) {
        /**
         * ETAG MATCH
         **/
        if (this.requrl == '/') {
            this.response.writeHead(301, {
                'Location': 'https://cdarcha.mzk.cz/cdarcha/'
            });
            this.response.end();
        }
        /**
         * ETAG MATCH
         **/
        if (etags[this.etag] !== undefined) {
            testLog("43", "[ETAG MATCH]");
            var sigla = Permissions_1.Permissions.refererValid(this.referer, this.remoteIP, this.encsigla);
            var etagPrefix = this.etag.substring(0, 4);
            Statistics_1.Statistics.addEtagStatisticByEtagPrefix(etagPrefix, sigla);
            this.response.statusCode = 304;
            this.response.end();
        }
        /**
         * STATICKE SOUBORY
         **/
        // http://cache.obalkyknih.cz/favicon.ico
        else if (this.requrl === '/favicon.ico' || this.requrl === '/cdarcha_klient/update-info.xml' || this.requrl === '/cdarcha_klient/CDArcha_klient_setup.exe' || this.requrl === '/cdarcha_klient/CDArcha_klient_setupNoAdmin.exe') {
            testLog("41", "[STATICKE SUBORY] Sigla:" + sigla);
            Statistics_1.Statistics.addFileRequests(sigla);
            testLog("41", "-> fileRequests[sigla]:" + Statistics_1.Statistics.fileRequests[sigla]);
            if (this.requrl.substring(this.requrl.length - 4) === '.ico')
                this.response.writeHead(200, { 'Etag': 'file-' + md5(this.requrl), 'Content-Type': 'image/x-icon' });
            if (this.requrl.substring(this.requrl.length - 2) === '.js')
                this.response.writeHead(200, { 'Etag': 'file-' + md5(this.requrl), 'Content-Type': 'text/javascript' });
            else
                this.response.writeHead(200, { 'Etag': 'file-' + md5(this.requrl) });
            etags['file-' + md5(this.requrl)] = null;
            var readStream = fs.createReadStream('static' + this.requrl);
            readStream.pipe(this.response);
        }
        /**
         * LET'S ENCRYPT CHALLENGE
         **/
        else if (this.requrl.substr(0, 12) === '/.well-known') {
            testLog("41", "[LETS ENCRYPT]");
            var fileName = this.requrl.substr(13);
            if (fs.existsSync(fileName)) {
                var readStream = fs.createReadStream(fileName);
                readStream.pipe(this.response);
            }
            else {
                s.send404IfNotValue(false);
            }
        }
        /**
         * WEB
         **/
        else if (this.requrl.indexOf(urlWeb) > 0) {
            if (!this.req.connection.encrypted) {
                this.response.writeHead(301, {
                    'Location': 'https://cdarcha.mzk.cz/' + this.requrl
                });
                this.response.end();
            }
            proxy.web(this.req, this.response, {
                target: 'http://localhost:8080/'
            });
        }
        /**
         * API IMPORT
         **/
        else if (this.requrl.indexOf(apiImport) > 0) {
            testLog("41", "[ API IMPORT ]");
            if (this.req.method == 'POST') {
                testLog("41", "POST");
                var boundary = multipart.getBoundary(this.req.headers['content-type']);
                Helpers_1.Helpers.checkApiLogin(s.db, this.query.login, this.query.password, this.query.version, apiVersion, function (resApiLogin, user) {
                    if (resApiLogin) {
                        s.response.writeHead(resApiLogin);
                        s.response.end();
                        return;
                    }
                    var body = '';
                    s.req.on('data', function (chunk) {
                        body += chunk;
                    });
                    s.req.on('end', function () {
                        testLog("41", "[ CHUNK FINISHED ]");
                        body = new Buffer(body, 'utf-8');
                        var res = 0;
                        console.log(body);
                        var parts = multipart.Parse(body, boundary);
                        var bibinfo = {};
                        var archive = {};
                        var media = {};
                        var metaxml;
                        var marcxml;
                        var mods;
                        for (var i = 0; i < parts.length; i++) {
                            var key = parts[i]['filename'];
                            var value = parts[i]['data'].toString('utf8');
                            console.log(key + '=' + value);
                            if (key == 'isbn')
                                key = 'ean13';
                            if (key == 'meta.xml') {
                                metaxml = value;
                                continue;
                            }
                            if (key == 'marcxml.xml') {
                                marcxml = value;
                                continue;
                            }
                            if (key == 'mods.xml') {
                                mods = value;
                                continue;
                            }
                            if (key == 'media_no') {
                                media.mediaNo = value;
                            }
                            bibinfo[key] = value;
                        }
                        /*************************************
                         * Vyhladat a vytvorit BIBLIO zaznam
                         ************************************/
                        Bibinfo_1.Bibinfo.searchAndCreate(s, bibinfo, function (biblio) {
                            // Vyhladaj BIBLIO zaznam, a v pripade ak neexistuje vytvor
                            var idBiblio;
                            console.dir(biblio);
                            console.log('^^^^^^^^^^^^^^^^^ BIBLIO ^^^^^^^^^^^^^^');
                            if (!biblio) {
                                var err = 'Bibinfo search and create failed';
                                console.log(err);
                                s.send404IfNotValue(res, err);
                                return false;
                            }
                            else {
                                idBiblio = biblio._id;
                            }
                            if (!idBiblio) {
                                var err = '[ ERR ] idBiblio undefined';
                                console.log(err);
                                s.send404IfNotValue(idBiblio, err);
                                return false;
                            }
                            /*************************************
                             * Vyhladat a vytvorit zaznam ARCHIVE
                             ************************************/
                            archive.biblio = idBiblio;
                            archive.creator = user._id;
                            Archive_1.Archive.searchOpenAndCreate(s, archive, function (archiveItems) {
                                var idArchive;
                                var uuid;
                                console.dir(archiveItems);
                                console.log('^^^^^^^^^^^^^^^^^ ARCHIVE ^^^^^^^^^^^^^^');
                                if (!archiveItems) {
                                    var err = 'Archive search and create failed';
                                    console.log(err);
                                    s.send404IfNotValue(res, err);
                                    return false;
                                }
                                else {
                                    idArchive = archiveItems._id;
                                    uuid = archiveItems.uuid;
                                }
                                if (!idArchive) {
                                    var err = '[ ERR ] idArchive undefined';
                                    console.log(err);
                                    s.send404IfNotValue(idArchive, err);
                                    return false;
                                }
                                // vytvorime adresar archivu, pokud jeste neexistuje
                                var archiveDir = storageFolder + '/' + uuid;
                                if (!fs.existsSync(archiveDir)) {
                                    fs.mkdirSync(archiveDir);
                                    fs.mkdirSync(archiveDir + '/data');
                                }
                                archiveDir = archiveDir + '/data';
                                /*************************************
                                 * Vyhladat a vytvorit zaznam MEDIA
                                 ************************************/
                                media.archive = idArchive;
                                Media_1.Media.searchAndCreate(s, media, function (mediaItems) {
                                    console.dir(mediaItems);
                                    console.log('^^^^^^^^^^^^^^^^^ MEDIA ^^^^^^^^^^^^^^');
                                    var idMedia;
                                    if (!mediaItems) {
                                        var err = 'Media search and create failed';
                                        console.log(err);
                                        s.send404IfNotValue(res, err);
                                        return false;
                                    }
                                    else {
                                        idMedia = mediaItems._id;
                                    }
                                    if (!idMedia) {
                                        var err = '[ ERR ] idMedia undefined';
                                        console.log(err);
                                        s.send404IfNotValue(idMedia, err);
                                        return false;
                                    }
                                    // vytvorime adresar popisnych metadat DMDSEC, pokud jeste neexistuje
                                    var dmdDir = archiveDir + '/dmdsec';
                                    if (!fs.existsSync(dmdDir)) {
                                        fs.mkdirSync(dmdDir);
                                    }
                                    // vytvorime adresar administracnich metadat AMDSEC, pokud jeste neexistuje
                                    var amdDir = archiveDir + '/amdsec';
                                    if (!fs.existsSync(amdDir)) {
                                        fs.mkdirSync(amdDir);
                                    }
                                    var filename, filenameFull;
                                    // META.xml - for each media
                                    if (metaxml.length) {
                                        filename = 'amd_mets_isoimg_' + idMedia + '.xml';
                                        filenameFull = amdDir + '/' + filename;
                                        (function (filename, filenameFull) {
                                            // files data to be writen to DB
                                            var fileinfo = {};
                                            fileinfo.fileName = filename;
                                            fileinfo.fileType = 'amdsec-media-meta';
                                            fileinfo.fileSize = metaxml.length;
                                            fileinfo.checkSum = crypto.createHash('md5').update(metaxml, 'utf8').digest('hex');
                                            fileinfo.media = idMedia;
                                            Files_1.Files.searchAndCreate(s, fileinfo, function (fileDoc) {
                                                // write file to storage
                                                fs.writeFileSync(filenameFull, metaxml);
                                            });
                                        }(filename, filenameFull));
                                    }
                                    // MARC.xml - for easinglech archive
                                    if (marcxml.length) {
                                        filename = 'dmd_marc_' + idArchive + '.xml';
                                        filenameFull = dmdDir + '/' + filename;
                                        (function (filename, filenameFull) {
                                            // files data to be writen to DB
                                            var fileinfo = {};
                                            fileinfo.fileName = filename;
                                            fileinfo.fileType = 'dmdsec-archive-marc';
                                            fileinfo.fileSize = marcxml.length;
                                            fileinfo.checkSum = crypto.createHash('md5').update(marcxml, 'utf8').digest('hex');
                                            fileinfo.archive = idArchive;
                                            Files_1.Files.searchAndCreate(s, fileinfo, function (fileDoc) {
                                                // write file to storage
                                                fs.writeFileSync(filenameFull, marcxml);
                                            });
                                        }(filename, filenameFull));
                                    }
                                    // MODS.xml - for single archive
                                    if (mods.length) {
                                        filename = 'dmd_mods_' + uuid + '.xml';
                                        filenameFull = dmdDir + '/' + filename;
                                        (function (filename, filenameFull) {
                                            // files data to be writen to DB
                                            var fileinfo = {};
                                            fileinfo.fileName = filename;
                                            fileinfo.fileType = 'dmdsec-archive-mods';
                                            fileinfo.fileSize = mods.length;
                                            fileinfo.checkSum = crypto.createHash('md5').update(mods, 'utf8').digest('hex');
                                            fileinfo.archive = idArchive;
                                            Files_1.Files.searchAndCreate(s, fileinfo, function (fileDoc) {
                                                // write file to storage
                                                var modsFormatted = xmlFormatter(mods, { indentation: "\t", stripComments: true });
                                                modsFormatted = modsFormatted.replace(new RegExp("\t<", 'g'), "\t<mods:");
                                                modsFormatted = modsFormatted.replace(new RegExp("\t</", 'g'), "\t</mods:");
                                                fs.writeFileSync(filenameFull, modsFormatted);
                                            });
                                        }(filename, filenameFull));
                                    }
                                    console.log('[ API IMPORT FINISHED ] idBiblio: ' + idBiblio.toString());
                                    console.log('[ API IMPORT FINISHED ] idArchive: ' + idArchive.toString());
                                    console.log('[ API IMPORT FINISHED ] idMedia (result): ' + idMedia.toString());
                                    s.response.writeHead(200);
                                    s.response.end(idMedia.toString());
                                });
                            });
                        });
                    });
                });
            }
            else {
                s.send404IfNotValue(false, 'POST method required');
            }
        } // API IMPORT
        /**
         * ISO FILE UPLOAD
         **/
        else if (this.requrl.indexOf(urlUpload) > 0) {
            testLog("41", "[ RECEIVING CHUNK ]");
            if (this.req.method == 'POST') {
                testLog("41", "POST");
                var mediaId = this.req.headers['x-cdarcha-mediaid'];
                var mediaChecksum = this.req.headers['x-cdarcha-checksum'];
                var fileType = this.req.headers['x-cdarcha-filetype'] || 'iso';
                var quickId = this.req.headers['x-cdarcha-quickid'] || '';
                var mediaSize = parseInt(this.req.headers['x-cdarcha-mediasize']) || 0;
                var mediaReadProblem = parseInt(this.req.headers['x-cdarcha-mediareadproblem']) || 0;
                var forcedUpload = parseInt(this.req.headers['x-cdarcha-forcedupload']) || 0;
                // mediaid a checksum je povinne
                if (!mediaId || !mediaChecksum) {
                    s.response.writeHead(404);
                    s.response.end('mediaid or checksum missing');
                    return;
                }
                var hash = crypto.createHash('md5');
                hash.setEncoding('hex');
                var writeStream = fs.createWriteStream(tmpFolder + '/iso/' + mediaId + '.iso', { flags: 'w' });
                this.req.pipe(writeStream, { end: false });
                this.req.pipe(hash);
                this.req.on('end', function () {
                    testLog("41", "[ CHUNK FINISHED ]");
                    writeStream.end();
                    hash.end();
                    var checksum = hash.read();
                    console.log('%%%%%%%');
                    console.log(mediaChecksum);
                    console.log(checksum);
                    console.log('%%%%%%%');
                    var success = (mediaChecksum == checksum);
                    var mediaFile = {
                        'fileType': fileType,
                        'checkSum': checksum,
                        'quickId': quickId,
                        'mediaSize': mediaSize,
                        'mediaReadProblem': mediaReadProblem,
                        'forcedUpload': forcedUpload,
                        'fileName': mediaId + '.iso',
                        'dtLastUpdate': new Date()
                    };
                    if (success) {
                        s.db.collection(mediaCollection).findOne({ _id: new mongo.ObjectID(mediaId) }, function (err, mediaItem) {
                            if (err) {
                                console.log(err);
                                s.send404IfNotValue(null, err);
                                return false;
                            }
                            var archiveId = mediaItem.archive;
                            s.db.collection(mediaCollection).update({ _id: new mongo.ObjectID(mediaId) }, { $set: mediaFile });
                            s.db.collection(archiveCollection).findOne({ _id: new mongo.ObjectID(archiveId) }, function (err, archive) {
                                if (err) {
                                    console.log(err);
                                    s.send404IfNotValue(null, err);
                                    return false;
                                }
                                // vytvorime adresar archivu, pokud jeste neexistuje
                                var archiveDir = storageFolder + '/' + archive.uuid;
                                if (!fs.existsSync(archiveDir)) {
                                    fs.mkdirSync(archiveDir);
                                    fs.mkdirSync(archiveDir + '/data');
                                }
                                archiveDir = archiveDir + '/data';
                                // vytvorime adresar media, pokud jeste neexistuje
                                var masterCopyDir = archiveDir + '/isoimage';
                                if (!fs.existsSync(masterCopyDir)) {
                                    fs.mkdirSync(masterCopyDir);
                                }
                                // uklidime docasny soubor
                                fs.copyFileSync(tmpFolder + '/iso/' + mediaId + '.iso', masterCopyDir + '/' + mediaId + '.' + fileType);
                                fs.unlinkSync(tmpFolder + '/iso/' + mediaId + '.iso');
                            });
                        });
                    }
                    else {
                        // kontrolni soucet nesedi, upload se nepoved, uklidime docasny soubor
                        fs.unlinkSync(tmpFolder + '/iso/' + mediaId + '.iso');
                    }
                    s.response.writeHead(200);
                    s.response.end('ok');
                });
            }
            else {
                this.send404IfNotValue(false, 'POST method required');
            }
        } // ISO FILE UPLOAD
        /**
         * COVER/TOC UPLOAD
         **/
        else if (this.requrl.indexOf(urlCoverUpload) > 0) {
            testLog("41", "[ API COVER UPLOAD ]");
            if (this.req.method == 'POST') {
                var boundary_1 = multipart.getBoundary(this.req.headers['content-type']);
                var boundaryRe_1 = new RegExp(boundary_1, 'g');
                var body = '', writeStream = null; // for streamed file write
                this.req.on('data', function (chunk) {
                    var chunkString = chunk.toString();
                    // indicates that next chunk will be octet stream
                    if (chunkString.match(/Content\-Type\: image\/tif/)) {
                        var fileNameArray = chunkString.match(/filename=\"(.*)\"/);
                        var fileName_1 = fileNameArray[1];
                        // finish octet stream if any (when transfering toc_2 after toc_1 after cover, ...)
                        if (writeStream) {
                            writeStream.end();
                            writeStream = null;
                        }
                        ;
                        if (!writeStream && fileName_1) {
                            // starting with incomming file stream
                            writeStream = fs.createWriteStream(tmpFolder + '/scan/' + boundary_1 + '-' + fileName_1, { flags: 'a' });
                        }
                        // text form data - octet stream form data header
                        body += chunk;
                    }
                    else if (writeStream) {
                        // continuing or ending octet stream
                        if (chunkString.match(boundaryRe_1)) {
                            // end of octet stream
                            writeStream.end();
                            // text form data
                            body += chunk;
                        }
                        else if (writeStream._writableState.ended == false) {
                            // continuing octet stream - write chunk to the file
                            writeStream.write(chunk);
                        }
                    }
                    else {
                        // text form data
                        body += chunk;
                    }
                });
                this.req.on('end', function () {
                    testLog("41", "[ CHUNK COVER UPLOAD FINISHED ]");
                    body = new Buffer(body, 'utf-8');
                    var parts = multipart.Parse(body, boundary_1);
                    var metaxml = '';
                    // media_id
                    var id = null;
                    for (var i = 0; i < parts.length; i++) {
                        var key = parts[i]['filename'];
                        var value = parts[i]['data'].toString('utf8');
                        if (key == 'id') {
                            id = value;
                            var idMatches = id.match(/[a-fA-F0-9]+/g);
                            if (idMatches && idMatches[0]) {
                                id = idMatches[0];
                            }
                        }
                        else if (key == 'meta.xml') {
                            metaxml = value;
                        }
                    }
                    if (!id) {
                        testLog("32", 'ID MISSING');
                        s.response.writeHead(404);
                        s.response.end('Archive or medium ID missing');
                        return;
                    }
                    // Je nam poskytnute jedno ID a nevime jestli media, nebo archivu (skenovat se muze k mediu = skutecny obrazek media, nebo k archivu = reprezentativny obrazek),
                    // proto zkusime jedno i druhe
                    (function (id, metaxml) {
                        s.db.collection(mediaCollection).findOne({ _id: new mongo.ObjectID(id) }, function (err, mediaDoc) {
                            if (err) {
                                console.dir(err);
                                s.response.writeHead(404);
                                s.response.end(JSON.stringify({ "status": "error", "msg": err }));
                                return;
                            }
                            var archiveId;
                            if (mediaDoc) {
                                archiveId = mediaDoc.archive;
                            }
                            else {
                                archiveId = id;
                            }
                            s.db.collection(archiveCollection).findOne({ _id: new mongo.ObjectID(archiveId) }, function (err, archiveDoc) {
                                if (err) {
                                    console.dir(err);
                                    s.response.writeHead(404);
                                    s.response.end(JSON.stringify({ "status": "error", "msg": err }));
                                    return;
                                }
                                var archiveUuid = archiveDoc.uuid;
                                var archiveDir = storageFolder + '/' + archiveUuid;
                                // search for cover+toc in form data
                                for (var i = 0; i < parts.length; i++) {
                                    (function (part) {
                                        var filename = part['filename'];
                                        // process octet stream = cover+toc
                                        var filenamePrefix9 = filename.substring(0, 9);
                                        var filenameFull = tmpFolder + '/scan/' + boundary_1 + '-' + filename;
                                        if (filenamePrefix9 == 'cover.tif' || filenamePrefix9 == 'toc_page_') {
                                            // open file to get md5 hash
                                            fs.readFile(filenameFull, function (err, fileData) {
                                                if (err) {
                                                    console.dir(err);
                                                    s.response.writeHead(404);
                                                    s.response.end(JSON.stringify({ "status": "error", "msg": err }));
                                                    return;
                                                }
                                                // get file size
                                                var stats = fs.statSync(filenameFull);
                                                var fileSizeInBytes = stats.size;
                                                // files data to be writen to DB
                                                var fileinfo = {};
                                                fileinfo.fileName = id + '-' + filename;
                                                fileinfo.fileType = (filenamePrefix9 == 'cover.tif' ? 'cover' : 'toc');
                                                fileinfo.fileSize = fileSizeInBytes;
                                                // get file checksum
                                                fileinfo.checkSum = crypto.createHash('md5').update(fileData, 'utf8').digest('hex');
                                                // archive or media id
                                                if (mediaDoc) {
                                                    fileinfo.media = mediaDoc._id;
                                                }
                                                else if (archiveDoc) {
                                                    fileinfo.archive = archiveDoc._id;
                                                }
                                                // write filedata to debug
                                                Files_1.Files.insertUnique(s, fileinfo, function (result) {
                                                    if (!fs.existsSync(archiveDir)) {
                                                        fs.mkdirSync(archiveDir);
                                                        fs.mkdirSync(archiveDir + '/data');
                                                    }
                                                    var masterCopyDir = archiveDir + '/data/mastercopyscan';
                                                    if (!fs.existsSync(masterCopyDir)) {
                                                        fs.mkdirSync(masterCopyDir);
                                                    }
                                                    // cleanup uploaded file
                                                    fs.copyFileSync(filenameFull, masterCopyDir + '/' + (mediaDoc ? mediaDoc._id : archiveDoc._id) + '-' + filename);
                                                    fs.unlinkSync(filenameFull);
                                                    var amdDir = archiveDir + '/data/amdsec';
                                                    if (!fs.existsSync(amdDir)) {
                                                        fs.mkdirSync(amdDir);
                                                    }
                                                    // META.xml - for each media
                                                    if (metaxml.length) {
                                                        if (mediaDoc) {
                                                            console.log('mediaDoc');
                                                            console.log(mediaDoc._id);
                                                        }
                                                        if (archiveDoc) {
                                                            console.log('archiveDoc');
                                                            console.log(archiveDoc._id);
                                                        }
                                                        var filenameDotParts = filename.split('.');
                                                        var filenameWoExtension = filenameDotParts[0];
                                                        var filenameMetaXml = 'amd_mets_' + (mediaDoc ? mediaDoc._id : archiveDoc._id) + '-' + filenameWoExtension + '.xml';
                                                        var filenameFullMetaXml = amdDir + '/' + filenameMetaXml;
                                                        (function (filenameFullMetaXml, scanFileId) {
                                                            // files data to be writen to DB
                                                            var fileinfo = {};
                                                            fileinfo.parent = scanFileId;
                                                            fileinfo.fileName = filenameMetaXml;
                                                            fileinfo.fileType = 'amdsec-scan-meta-' + result.fileType;
                                                            fileinfo.fileSize = metaxml.length;
                                                            fileinfo.checkSum = crypto.createHash('md5').update(metaxml, 'utf8').digest('hex');
                                                            if (mediaDoc) {
                                                                fileinfo.media = mediaDoc._id;
                                                            }
                                                            else {
                                                                fileinfo.archive = archiveDoc._id;
                                                            }
                                                            Files_1.Files.insertUnique(s, fileinfo, function () {
                                                                // write file to storage
                                                                fs.writeFileSync(filenameFullMetaXml, metaxml);
                                                            });
                                                        }(filenameFullMetaXml, result._id));
                                                    }
                                                });
                                            });
                                        }
                                    }(parts[i]));
                                }
                            });
                        });
                    })(id, metaxml);
                    console.log('[ API COVER UPLOAD FINISHED ]');
                    s.response.writeHead(200);
                    s.response.end('ok');
                });
            }
            else {
                s.send404IfNotValue(false, 'POST method required');
            }
        } // COVER/TOC UPLOAD
        /**
         * API GET HASH
         **/
        else if (this.requrl.indexOf(apiChecksum) > 0) {
            testLog("41", "[ API CHECKSUM ]");
            if (!this.query.mediaid) {
                s.response.writeHead(404);
                s.response.end(JSON.stringify({ "status": "mediaid missing" }));
                return;
            }
            s.db.collection(mediaCollection).findOne({ _id: new mongo.ObjectID(this.query.mediaid) }, function (err, item) {
                if (err) {
                    s.response.writeHead(404);
                    s.response.end(JSON.stringify({ "status": "error", "msg": err }));
                    return;
                }
                if (!item) {
                    s.response.writeHead(200);
                    s.response.end(JSON.stringify({ "status": "not found" }));
                    return;
                }
                if (!item.checkSum) {
                    s.response.writeHead(200);
                    s.response.end(JSON.stringify({ "status": "not prepared" }));
                }
                else {
                    s.response.writeHead(200);
                    s.response.end(JSON.stringify({ "status": "ok", "hash": item.checkSum }));
                }
            });
        } // API GET HASH
        /**
         * API GET MEDIA
         **/
        else if (this.requrl.indexOf(apiGetMedia) > 0) {
            testLog("41", "[ API GET MEDIA ]");
            if (!this.query.quickid) {
                s.response.writeHead(404);
                s.response.end(JSON.stringify({ "status": "quickid missing" }));
                return;
            }
            s.db.collection(mediaCollection).findOne({ 'quickId': this.query.quickid }, function (err, media) {
                if (err) {
                    s.response.writeHead(404);
                    s.response.end(JSON.stringify({ "status": "error", "msg": err }));
                    return;
                }
                if (!media) {
                    s.response.writeHead(200);
                    s.response.end(JSON.stringify({ "status": "media not found" }));
                    return;
                }
                s.db.collection(archiveCollection).findOne({ _id: media.archive }, function (err, archive) {
                    if (err) {
                        s.response.writeHead(404);
                        s.response.end(JSON.stringify({ "status": "error", "msg": err }));
                        return;
                    }
                    if (!archive) {
                        s.response.writeHead(200);
                        s.response.end(JSON.stringify({ "status": "archive not found" }));
                        return;
                    }
                    s.db.collection(metaCollection).findOne({ _id: archive.biblio }, function (err, biblio) {
                        if (err) {
                            s.response.writeHead(404);
                            s.response.end(JSON.stringify({ "status": "error", "msg": err }));
                            return;
                        }
                        if (!biblio) {
                            s.response.writeHead(200);
                            s.response.end(JSON.stringify({ "status": "biblio not found" }));
                            return;
                        }
                        s.response.writeHead(200);
                        s.response.end(JSON.stringify({
                            "dtUpdate": media.dtLastUpdate.getDate() + '.' + (media.dtLastUpdate.getMonth() + 1) + '.' + media.dtLastUpdate.getFullYear(),
                            "title": biblio.title,
                            "authors": biblio.authors,
                            "year": biblio.year,
                            "size": media.mediaSize,
                            "mediaReadProblem": media.mediaReadProblem
                        }));
                    });
                });
            });
        } // API GET MEDIA
        /**
         * API GET ALL MEDIA
         * Vylistuje vsechny archivy a media k danemu bibliografickemu zaznamu
         **/
        else if (this.requrl.indexOf(apiGetAllMediaList) > 0) {
            testLog("41", "[ API GET ALL MEDIA LIST ]");
            Helpers_1.Helpers.checkApiLogin(s.db, this.query.login, this.query.password, this.query.version, apiVersion, function (resApiLogin) {
                if (resApiLogin) {
                    s.response.writeHead(resApiLogin);
                    s.response.end();
                    return;
                }
                else if (s.req.method == 'POST') {
                    testLog("41", "POST");
                    var boundary = multipart.getBoundary(s.req.headers['content-type']);
                    var body = '';
                    s.req.on('data', function (chunk) {
                        body += chunk;
                    });
                    s.req.on('end', function () {
                        testLog("41", "[ CHUNK FINISHED ]");
                        body = new Buffer(body, 'utf-8');
                        var parts = multipart.Parse(body, boundary);
                        var bibinfo = {};
                        for (var i = 0; i < parts.length; i++) {
                            var key = parts[i]['filename'];
                            if (key == 'isbn')
                                key = 'ean13';
                            if (key == 'ean13' || key == 'ismn' || key == 'oclc' || key == 'nbn' || key == 'uuid' || key == 'title' || key == 'authors' || key == 'year' || key.slice(0, 5) == 'part_') {
                                bibinfo[key] = parts[i]['data'].toString('utf8');
                            }
                        }
                        /*************************************
                         * Vyhladat a vytvorit BIBLIO zaznam
                         ************************************/
                        Bibinfo_1.Bibinfo.search(s, bibinfo, function (biblio) {
                            // Vyhladaj BIBLIO zaznam
                            var idBiblio;
                            if (!biblio) {
                                s.response.writeHead(200);
                                s.response.end();
                                return false;
                            }
                            else {
                                idBiblio = biblio._id;
                            }
                            s.db.collection(archiveCollection).findOne({ biblio: idBiblio }, function (err, archive) {
                                // Vyhladaj ARCHIVE zaznam
                                var idArchive;
                                if (!archive) {
                                    s.response.writeHead(200);
                                    s.response.end();
                                    return false;
                                }
                                else {
                                    idArchive = archive._id;
                                }
                                var archiveDate = new Date(archive.dtLastUpdate);
                                var out = new Array();
                                out.push({
                                    'id': idArchive,
                                    'type': 'archive',
                                    'mediaNo': null,
                                    'status': archive.status,
                                    'dtLastUpdate': archive.dtLastUpdate,
                                    'text': 'Archiv:   ' + idArchive + '   (' + archiveDate.getDate() + '.' + archiveDate.getMonth() + '.' + archiveDate.getFullYear() + ')'
                                });
                                s.db.collection(mediaCollection).find({ archive: idArchive }).sort({ mediaNo: 1 }).toArray(function (err, media) {
                                    // Vyhladaj MEDIA zaznam
                                    if (media && media.length) {
                                        for (var i = 0; i < media.length; i++) {
                                            var item = media[i];
                                            var mediaDate = new Date(item.dtLastUpdate);
                                            out.push({
                                                'id': item._id,
                                                'type': 'media',
                                                'mediaNo': item.mediaNo,
                                                'status': null,
                                                'dtLastUpdate': item.dtLastUpdate,
                                                'text': 'MÃ©dium:   ' + item.mediaNo + '   (' + mediaDate.getDate() + '.' + mediaDate.getMonth() + '.' + mediaDate.getFullYear() + ')'
                                            });
                                        }
                                    }
                                    s.response.writeHead(200);
                                    s.response.end(JSON.stringify(out));
                                });
                            });
                        });
                    });
                }
            });
        } // API GET ALL MEDIA
        /**
         * API CLOSE ARCHIVE
         * Close archive record
         **/
        else if (this.requrl.indexOf(apiCloseArchive) > 0) {
            testLog("41", "[ API CLOSE ARCHIVE ]");
            var id_1 = this.query.id;
            if (!id_1) {
                s.response.writeHead(404);
                s.response.end(JSON.stringify({ "status": "id missing" }));
                return;
            }
            s.db.collection(archiveCollection).findOne({ _id: new mongo.ObjectID(id_1) }, function (err, archiveDoc) {
                if (err) {
                    console.dir(err);
                    s.response.writeHead(404);
                    s.response.end(JSON.stringify({ "status": "error", "msg": err }));
                    return;
                }
                s.db.collection(mediaCollection).findOne({ _id: new mongo.ObjectID(id_1) }, function (err, mediaDoc) {
                    if (err) {
                        console.dir(err);
                        s.response.writeHead(404);
                        s.response.end(JSON.stringify({ "status": "error", "msg": err }));
                        return;
                    }
                    var archiveId = archiveDoc ? id_1 : mediaDoc.archive;
                    s.db.collection(archiveCollection).update({ _id: new mongo.ObjectID(archiveId) }, { $set: { status: 1 } });
                });
            });
        }
        /**
         * FILE COVER
         **/
        // http://cache.obalkyknih.cz/file/cover/1143894/medium
        else if (this.requrl.indexOf(urlCoverFile) > 0) {
            var sigla = Permissions_1.Permissions.refererValid(this.referer, this.remoteIP, this.encsigla);
            testLog("41", "[FILE COVER] Sigla:" + sigla);
            if (!this.isRequestValid(sigla, true)) {
                console.log('>>> referer not valid: ' + this.referer + ' from IP: ' + this.remoteIP + ' request: ' + this.requrl);
                return;
            }
            // cover request
            Statistics_1.Statistics.addCoverRequests(sigla);
            testLog("44", "-> requrl.split('?')[0]:" + this.requrl.split('?')[0]);
            this.cover(this, this.requrl.split('?')[0]);
        }
        /**
         * FILE MASTER
         **/
        // http://cache1.obalkyknih.cz/file/master/1449055
        else if ((this.requrl.indexOf(urlMasterFile)) > 0) {
            var sigla = Permissions_1.Permissions.refererValid(this.referer, this.remoteIP, this.encsigla);
            if (!this.isRequestValid(sigla, true)) {
                console.log('>>> referer not valid: ' + this.referer + ' from IP: ' + this.remoteIP + ' request: ' + this.requrl);
                return;
            }
            Statistics_1.Statistics.addFileMasterRequests(sigla);
            // master request
            var tmpUri = this.requrl.split('?')[0];
            var uriSegments = tmpUri.split('/');
            if (isNaN(uriSegments[3])) {
                s.send404IfNotValue(false, 'Wrong request');
                return;
            }
            tmpUri = '/file/cover/' + uriSegments[3] + '/master';
            testLog("41", "-> FILE MASTER request:" + urlMain + '/' + tmpUri);
            var options = {
                hostname: urlMain,
                path: tmpUri
            };
            var reqMasterData = http.request(options, function (res) {
                testLog("41", "-> fileOrigRequests[sigla]:" + Statistics_1.Statistics.fileMasterRequests[sigla]);
                if (res.statusCode !== 200) {
                    s.send404IfNotValue(false);
                    return;
                }
                var data = [];
                res.on('error', function (e) {
                    console.log(e);
                });
                res.on('data', function (chunk) {
                    s.response.write(chunk);
                }); //.pipe(response);
                res.on('end', function () {
                    s.response.end();
                });
            });
            reqMasterData.setTimeout(timeout, function () {
                s.req.abort();
                s.response.end();
            });
            reqMasterData.on('error', function (err) {
                if (err.code === "ECONNRESET") {
                    console.log('file master timeout occurs');
                }
            });
            reqMasterData.end();
        }
        /**
         * FILE TOC (thumbnail + pdf)
         **/
        // http://cache.obalkyknih.cz/file/toc/142444/thumbnail
        // http://cache.obalkyknih.cz/file/toc/142444/pdf
        else if ((this.requrl.indexOf(urlTocFile)) > 0) {
            var sigla = Permissions_1.Permissions.refererValid(this.referer, this.remoteIP, this.encsigla);
            testLog("41", "[FILE TOC] Sigla:" + sigla);
            if (!this.isRequestValid(sigla, true)) {
                console.log('>>> referer not valid: ' + this.referer + ' from IP: ' + this.remoteIP + ' request: ' + this.requrl);
                return;
            }
            var reqUrl = this.requrl.split('?')[0];
            testLog("41", "-> reqUrl:" + reqUrl);
            if ((reqUrl.indexOf(uriPartTocThumbnail)) > 0) {
                // TOC thumbnail request
                testLog("44", "->-> TOC thumbnail request");
                Statistics_1.Statistics.addTocThumbnailRequests(sigla);
                this.cover(this, reqUrl);
            }
            else if ((reqUrl.indexOf(uriPartTocPdf)) > 0) {
                // TOC file request
                testLog("44", "->-> TOC pdf file request");
                Statistics_1.Statistics.addTocPdfRequests(sigla);
                this.toc(this, reqUrl);
            }
        }
        /**
         * FILE STORAGE
         **/
        else if ((this.requrl.indexOf(urlStorage)) > 0) {
            //var sigla: any = Permissions.refererValid(this.referer, this.remoteIP, this.encsigla);
            testLog("41", "[FILE STORAGE] Sigla:" + sigla);
            //if (!this.isRequestValid(sigla, true)) {
            //    console.log('>>> referer not valid: ' + this.referer + ' from IP: ' + this.remoteIP + ' request: ' + this.requrl);
            //    return;
            //}
            var reqUrl = this.requrl.split('?')[0];
            var file = storageFolder + '/' + reqUrl.substring(urlStorage.length + 1);
            testLog("41", "-> reqUrl:" + reqUrl);
            if (fs.existsSync(file)) {
                if ((this.requrl.indexOf('.iso')) > 0) {
                    s.response.writeHead(200, { 'Content-Type': 'application/iso' });
                }
                else {
                    s.response.writeHead(200, { 'Content-Type': 'text/xml' });
                }
                var readStream = fs.createReadStream(file);
                readStream.pipe(this.response);
            }
            else {
                s.send404IfNotValue(null, 'No such file in storage.');
            }
        }
        /**
         * API COVER
         **/
        // http://cache.obalkyknih.cz/api/cover/?multi={"isbn":"1210-8480","nbn":"cnb000359017"}
        // http://cache.obalkyknih.cz/api/cover/?isbn=1210-8480
        else if ((this.requrl.indexOf(urlCoverApi)) > 0) {
            var sigla = Permissions_1.Permissions.refererValid(this.referer, this.remoteIP, this.encsigla);
            var testEnvRequest = s.query.testenv || '';
            if (testEnvRequest == 'XcDf2FvUP')
                sigla = 'Booga1';
            testLog("41", "[API COVER] Sigla:" + sigla);
            if (!this.isRequestValid(sigla, true, true)) {
                console.log('>>> referer not valid: ' + this.referer + ' from IP: ' + this.remoteIP + ' request: ' + this.requrl);
                return;
            }
            Statistics_1.Statistics.addCoverApiRequests(sigla);
            var result = this.getResult();
            if (this.sendPlaceholderIfNotValue(result)) {
                return;
            }
            testLog("34", "-> db.collection(metaCollection).find(sel) : db.collection(" + metaCollection + ").find(" + result.sel + ")");
            this.db.collection(metaCollection).find(result.sel).toArray(function (err, items_raw) {
                if (!items_raw.length) {
                    // obalka neni v DB a je potrebne nacist z back-end API metadata
                    // funkce metadata() rovnou posle klientovi obalku
                    s.metadata(s, [{ bibinfo: result.bib, permalink: "a" }], [], true, false, false);
                    return;
                }
                // Projdi doposud ziskane vysledky z DB
                if (items_raw) {
                    var items = s.getSortedItemsFromItemsRaw(items_raw);
                    var bibinfo = result.bib;
                    var found = false; // prvni shoda a dost
                    for (var i = 0; i < items.length; i++) {
                        var itemInfo = s.getItemInfoFromItem(items[i]);
                        /* Spolecne chovani BE a FE pri rozhodovani nad dotazy s vice parametry:
                         * Uplatnuje se priorita parametru v tomto poradi ISBN, OCLC, NBN, ISMN.
                         * Pokud mame 2 zaznamy, kde ISBN=1, OCLC=2, NBN=3 a ISBN=1, OCLC=2, NBN=4 a
                         * zeptame se na ISNB=1 dostaneme 1.zaznam, pokud se zeptame na OCLC=2 dostaneme
                         * taky 1.zaznam, pokud se zeptame na NBN=4 dostaneme 2.zaznam.
                         * Ale pokud se zeptame na kombinaci ISBN=1 + NBN=4 dostaneme 1.zaznam, protoze
                         * prioritni je ISBN a zhoda se nasla uz pri prvnim zaznamu, dale se nepokracuje.

                         * FE operuje s 2 zdroji: lokalni MongoDB a BE API
                         * Rozdil ve vysledku mezi odpovedi BE a FE muze nastat prave pri duplikovanych
                         * zaznamu z prikladu v predchozim odstavci. Pokud zaznam c.1 jeste nebude dotazen
                         * na FE a zeptame se na kombinaci ISBN=1 + NBN=4 dostaneme jako vysledek 2. zaznam.*/
                        if (itemInfo.item !== null && s.isGoodItemInfoForBibInfo(itemInfo, bibinfo)) {
                            // uplatneni priority parametru
                            // 0=ISBN, 1=OCLC, 2=NBN, 3=UUID, 4=ISMN, 5=ISBN_OTHER
                            for (var j = 0; j <= 5; j++) {
                                var found = s.itemFound(itemInfo, bibinfo, j);
                                if (found) {
                                    var coverUrl = Helpers_1.Helpers.getUrlByType(itemInfo.item, s.query.type);
                                    if (s.sendPlaceholderIfNotValue(coverUrl)) {
                                        return;
                                    }
                                    else {
                                        s.cover(s, coverUrl, true, false);
                                        return;
                                    }
                                }
                            }
                        }
                    } // for items
                    // obalka neni v DB a je potrebne nacist z back-end API metadata
                    // funkce metadata() rovnou posle klientovi obalku
                    s.metadata(s, [{ bibinfo: result.bib, permalink: "a" }], [], true, false, false);
                    return;
                } // if items
            });
        }
        /**
         * API TOC THUMBNAIL
         **/
        // http://cache2.obalkyknih.cz/api/toc/thumbnail?multi={%22isbn%22:%221212-8570%22}
        // http://cache2.obalkyknih.cz/api/toc/thumbnail?isbn=1212-8570
        else if ((this.requrl.indexOf(urlTocApiThumbnail)) > 0) {
            var sigla = Permissions_1.Permissions.refererValid(this.referer, this.remoteIP, this.encsigla);
            if (!this.isRequestValid(sigla, true, true)) {
                console.log('>>> referer not valid: ' + this.referer + ' from IP: ' + this.remoteIP + ' request: ' + this.requrl);
                return;
            }
            Statistics_1.Statistics.addTocThumbnailApiRequests(sigla);
            var result = this.getResult();
            if (this.sendPlaceholderIfNotValue(result)) {
                return;
            }
            this.db.collection(metaCollection).find(result.sel).toArray(function (err, items_raw) {
                if (!items_raw.length) {
                    // obalka neni v DB a je potrebne nacist z back-end API metadata
                    // funkce metadata() rovnou posle klientovi obalku
                    s.metadata(s, [{ bibinfo: result.bib, permalink: "a" }], [], false, true, false);
                    return;
                }
                // Projdi doposud ziskane vysledky z DB
                if (items_raw) {
                    var items = s.getSortedItemsFromItemsRaw(items_raw);
                    var bibinfo = result.bib;
                    var found = false; // prvni shoda a dost
                    for (var i = 0; i < items.length; i++) {
                        var itemInfo = s.getItemInfoFromItem(items[i]);
                        /* Blizsie info u API COVER */
                        if (itemInfo.item !== null && s.isGoodItemInfoForBibInfo(itemInfo, bibinfo)) {
                            // uplatneni priority parametru
                            // 0=ISBN, 1=OCLC, 2=NBN, 3=UUID, 4=ISMN, 5=ISBN_OTHER
                            for (var j = 0; j <= 5; j++) {
                                var found = s.itemFound(itemInfo, bibinfo, j);
                                if (found) {
                                    var tocThumbnailUrl = Helpers_1.Helpers.getUrlByType(itemInfo.item, 'toc_thumbnail');
                                    if (s.sendPlaceholderIfNotValue(tocThumbnailUrl)) {
                                        return;
                                    }
                                    //console.log(tocThumbnailUrl);
                                    s.cover(s, tocThumbnailUrl, false, true);
                                    return;
                                }
                            }
                        }
                    } // for items
                    // obalka neni v DB a je potrebne nacist z back-end API metadata
                    // funkce metadata() rovnou posle klientovi obalku
                    s.metadata(s, [{ bibinfo: result.bib, permalink: "a" }], [], false, true, false);
                    return;
                } // if items
            });
        }
        /**
         * API TOC PDF
         **/
        // http://cache2.obalkyknih.cz/api/toc/pdf?multi={%22isbn%22:%221212-8570%22}
        // http://cache2.obalkyknih.cz/api/toc/pdf?isbn=1212-8570
        else if ((this.requrl.indexOf(urlTocApiPdf)) > 0) {
            var sigla = Permissions_1.Permissions.refererValid(this.referer, this.remoteIP, this.encsigla);
            if (!this.isRequestValid(sigla, true, true)) {
                console.log('>>> referer not valid: ' + this.referer + ' from IP: ' + this.remoteIP + ' request: ' + this.requrl);
                return;
            }
            Statistics_1.Statistics.addTocPdfApiRequests(sigla);
            var result = this.getResult();
            var ipv4 = this.remoteIP;
            if (ipv4.indexOf('::ffff:') !== -1)
                ipv4 = ipv4.substring(7);
            if (this.send404IfNotValue(result, 'Unknown referer. You need to sign up at http://www.obalkyknih.cz and provide your catalog URL. Referer: ' + this.referer + '  IP: ' + ipv4)) {
                return;
            }
            this.db.collection(metaCollection).find(result.sel).toArray(function (err, items_raw) {
                if (!items_raw.length) {
                    // obalka neni v DB a je potrebne nacist z back-end API metadata
                    // funkce metadata() rovnou posle klientovi obalku
                    s.metadata(s, [{ bibinfo: result.bib, permalink: "a" }], [], false, false, true);
                    return;
                }
                // Projdi doposud ziskane vysledky z DB
                if (items_raw) {
                    var items = s.getSortedItemsFromItemsRaw(items_raw);
                    var bibinfo = result.bib;
                    var found = false; // prvni shoda a dost
                    for (var i = 0; i < items.length; i++) {
                        var itemInfo = s.getItemInfoFromItem(items[i]);
                        /* Blizsie info u API COVER */
                        if (itemInfo.item !== null && s.isGoodItemInfoForBibInfo(itemInfo, bibinfo)) {
                            // uplatneni priority parametru
                            // 0=ISBN, 1=OCLC, 2=NBN, 3=UUID, 4=ISMN, 5=ISBN_OTHER
                            for (var j = 0; j <= 5; j++) {
                                var found = s.itemFound(itemInfo, bibinfo, j);
                                if (found) {
                                    if (!itemInfo.item.toc_pdf_url) {
                                        s.send404IfNotValue(false);
                                        return;
                                    }
                                    else {
                                        s.toc(s, itemInfo.item.toc_pdf_url);
                                        return;
                                    }
                                }
                            }
                        }
                    } // for items
                    // obalka neni v DB a je potrebne nacist z back-end API metadata
                    // funkce metadata() rovnou posle klientovi obalku
                    s.metadata(s, [{ bibinfo: result.bib, permalink: "a" }], [], false, false, true);
                    return;
                } // if items
            });
        }
        /**
         * METADATA
         **/
        // http://cache1.obalkyknih.cz/api/books/?multi=[{%22isbn%22:%229788376663103%22},{%22isbn%22:%229788376663203%22}]&sigla=CBA001&pretty=1
        else if ((this.requrl.indexOf(urlMetadata)) > 0) {
            //var sigla: any = Permissions.ipValid(this.xreferer, this.remoteIP, this.query.sigla);
            var fetcha = []; // pole objektu s parametry {isbn:xxx},{isbn:yyy,nbn:zzz}
            //if (!this.isRequestValid(sigla, true, true)) {
            //    console.log('>>> xreferer or ip not valid: ' + this.xreferer + ' from IP: ' + this.remoteIP + ' request: ' + this.requrl);
            //    return;
            //}
            //Statistics.addMetaRequests(sigla);
            var ean = '';
            var isbns = []; // temporary
            var isbna = []; // pole s ISBN identifikatory
            var nbns = []; // temporary
            var nbna = []; // pole s NBN identifikatory
            var ismns = []; // temporary
            var ismna = []; // pole s ISMN identifikatory
            var oclcs = []; // temporary
            var oclca = []; // pole s OCLC identifikatory
            var uuida = []; // pole s UUID identifikatory (Kramerius)
            var multis = []; // temporary
            var resSimple = this.query.simple;
            for (var queryKey in this.query) {
                if (queryKey == 'isbn' || queryKey == 'ean') {
                    var isbns = queryKey == 'isbn' ? this.query.isbn.split(',') : this.query.ean.split(',');
                    for (var i = 0; i < isbns.length; i++) {
                        var isbn = isbns[i];
                        if (!isbn)
                            continue;
                        isbn = isbn.split(' ')[0];
                        ean = toEan(isbn);
                        if (ean === null)
                            continue;
                        isbna.push(ean);
                        fetcha.push({ isbn: isbn }); // pole objektu s dotazy
                    }
                }
                else if (queryKey == 'nbn') {
                    var nbns = this.query.nbn.split(',');
                    for (var i = 0; i < nbns.length; i++) {
                        var nbn = nbns[i];
                        if (!nbn)
                            continue;
                        nbna.push(nbn);
                        fetcha.push({ nbn: nbn }); // pole objektu s dotazy
                    }
                }
                else if (queryKey == 'ismn') {
                    var ismns = this.query.ismn.split(',');
                    for (var i = 0; i < ismns.length; i++) {
                        var ismn = ismns[i];
                        if (!ismn)
                            continue;
                        ismna.push(ismn);
                        fetcha.push({ ismn: ismn }); // pole objektu s dotazy
                    }
                }
                else if (queryKey == 'oclc') {
                    var oclcs = this.query.oclc.split(',');
                    for (var i = 0; i < oclcs.length; i++) {
                        var oclc = oclcs[i];
                        if (!oclc)
                            continue;
                        oclca.push(oclc);
                        fetcha.push({ oclc: oclc }); // pole objektu s dotazy
                    }
                }
                else if (queryKey == 'multi') {
                    try {
                        var multis = JSON.parse(decodeURIComponent(this.query.multi));
                    }
                    catch (err) {
                        this.send404IfNotValue(false, 'Check query syntax');
                        return;
                    }
                    for (var i = 0; i < multis.length; i++) {
                        var multi = multis[i];
                        var fetchMulti = {}; // temporary
                        // odlozeni originalniho pozadavku bibinfo (bude vracen tak jak je v odpovedi)
                        fetchMulti.bibinfo = {};
                        for (var property in multi) {
                            if (multi.hasOwnProperty(property) && property != 'bibinfo') {
                                fetchMulti.bibinfo[property] = multi[property];
                            }
                        }
                        // parsovani identifikatoru vicesvazkoveho dila a periodika (parse_note se pouziva pokud knihovni system nema data rok/rocnik/cislo/cislo casti/nazev casti oddelene)
                        if (multi.part_note) {
                            var parts = partParser.parse(multi.part_note);
                            if (parts.year)
                                multi.part_year = parts.year;
                            if (parts.volume)
                                multi.part_volume = parts.volume;
                            if (parts.part)
                                multi.part_no = parts.part;
                            if (parts.part && !parts.year && !parts.volume)
                                multi.part_name = parts.part;
                        }
                        // validation
                        if (!Helpers_1.Helpers.partValidation(multi)) {
                            // jedna z casti obsahuje zakazane znaky, nebo kombinace casti neni validni
                            delete multi.part_year;
                            delete multi.part_volume;
                            delete multi.part_no;
                            delete multi.part_name;
                        }
                        // normalizace
                        if (multi.part_year)
                            multi.part_year = partParser.normalizeYear(multi.part_year);
                        if (multi.part_volume)
                            multi.part_volume = partParser.normalizeVolume(multi.part_volume);
                        if (multi.part_no)
                            multi.part_no = partParser.normalizePart(multi.part_no);
                        if (multi.part_name)
                            multi.part_name = partParser.normalizePart(multi.part_name);
                        // normalizace spatne zduplikovaneho roku, rocniku, nebo cisla v pozadavku
                        if (multi.part_year && multi.part_volume && multi.part_year == multi.part_volume) {
                            if (multi.part_year.length == 4)
                                delete multi.part_volume;
                            else
                                delete multi.part_year;
                        }
                        if (multi.part_year && multi.part_no && multi.part_year == multi.part_no) {
                            if (multi.part_year.length == 4)
                                delete multi.part_no;
                        }
                        for (var key in multi) {
                            if (key == 'isbn' || key == 'ean') {
                                isbn = key == 'isbn' ? multi.isbn.split(' ')[0] : multi.ean.split(' ')[0];
                                ean = toEan(isbn);
                                if (ean !== null) {
                                    isbna.push(ean);
                                    fetchMulti.isbn = isbn;
                                }
                            }
                            if (key == 'oclc') {
                                oclca.push(multi.oclc);
                                fetchMulti.oclc = multi.oclc;
                            }
                            if (key == 'nbn') {
                                nbna.push(multi.nbn);
                                fetchMulti.nbn = multi.nbn;
                            }
                            if (key == 'ismn') {
                                ismna.push(multi.ismn);
                                fetchMulti.ismn = multi.ismn;
                            }
                            if (key == 'uuid') {
                                uuida.push(multi.uuid);
                                fetchMulti.uuid = multi.uuid;
                            }
                            // U /api/book se dotazujeme na vic zaznamu, proto pozadavek pouze zaznamename, ale do DB se dotazujeme
                            // pomoci isbn, nbn, ismn, oclc. Pozadavek bude naparovany na ziskane zaznamy z MongoDB.
                            if (key == 'part_year') {
                                fetchMulti.part_year = multi.part_year;
                            }
                            if (key == 'part_volume') {
                                fetchMulti.part_volume = multi.part_volume;
                            }
                            if (key == 'part_no') {
                                fetchMulti.part_no = multi.part_no;
                            }
                            if (key == 'part_name') {
                                fetchMulti.part_name = multi.part_name;
                            }
                        }
                        fetcha.push(fetchMulti); // pole objektu s dotazy
                    }
                }
            }
            this.response.writeHead(200, { 'Content-Type': 'text/plain' });
            var json = [];
            // pole objektu fetcha prevedeno na pole retezcu; bude se parovat na odpoved bibinfo z BE
            var fetchaStr = [];
            for (var i = 0; i < fetcha.length; i++) {
                if (fetcha[i]) {
                    fetchaStr[i] = Helpers_1.Helpers.getSortedBibinfo(fetcha[i].bibinfo);
                }
            }
            var dbFind = [];
            if (isbna.length) {
                dbFind.push({ ean13: { $in: isbna } });
                dbFind.push({ ean13_other: { $in: isbna } });
            }
            if (nbna.length)
                dbFind.push({ nbn: { $in: nbna } });
            if (ismna.length)
                dbFind.push({ ismn: { $in: ismna } });
            if (oclca.length)
                dbFind.push({ oclc: { $in: oclca } });
            if (uuida.length)
                dbFind.push({ uuid: { $in: uuida } });
            if (!dbFind.length) {
                this.send404IfNotValue(false, '[]');
                return;
            }
            this.db.collection(metaCollection).find({ $or: dbFind }).toArray(function (err, items_raw) {
                /* Projdi doposud ziskane vysledky z DB
                 * prirad jednotlivym dotazum odpovedi z DB (jeden zaznam muze byt odpoved na vic dotazu)
                 * dotazy, na ktere se nedohledaji zaznamy budou pouzite jako novy dotaz na API BE serveru */
                if (items_raw) {
                    var items = s.getSortedItemsFromItemsRaw(items_raw);
                    for (var i = 0; i < items.length; i++) {
                        var itemInfo = s.getItemInfoFromItem(items[i]);
                        /* Blizsie info u API COVER */
                        if (itemInfo.item !== null) {
                            // uplatneni priority parametru
                            // 0=ISBN, 1=OCLC, 2=NBN, 3=UUID, 4=ISMN, 5=OTHER ISBN
                            for (var j = 0; j <= 5; j++) {
                                // projdi dotazy (naparuje dotazy na ziskanou polozku z DB a posklada odpoved metadata API)
                                for (var k in fetcha) {
                                    var bibinfo = fetcha[k];
                                    var found = false;
                                    if (!s.isGoodItemInfoForBibInfo(itemInfo, bibinfo)) {
                                        continue;
                                    }
                                    var found = s.itemFound(itemInfo, bibinfo, j);
                                    if (found) {
                                        itemInfo.item.bibinfo = bibinfo.bibinfo;
                                        var pos = fetchaStr.indexOf(Helpers_1.Helpers.getSortedBibinfo(itemInfo.item.bibinfo));
                                        if (pos >= 0) {
                                            json[pos] = Helpers_1.Helpers.replaceUrl(itemInfo.item, resSimple);
                                            delete fetchaStr[pos];
                                        }
                                        else {
                                            json.push(Helpers_1.Helpers.replaceUrl(itemInfo.item, resSimple));
                                        }
                                        delete fetcha[k];
                                    }
                                }
                            }
                            if (!fetcha.length)
                                break;
                        }
                    } // for items
                } // if items
                s.response.writeHead(200);
                s.response.end(JSON.stringify(json, null, ' '));
                //s.metadata(s, json);
            });
        }
        /**
         * STATISTIKY
         **/
        else if (this.query.stats === 'true') {
            var sigla = Permissions_1.Permissions.ipValid(this.xreferer, this.remoteIP, this.query.sigla);
            if (!sigla && (this.remoteIP === '127.0.0.1' || this.remoteIP === '::1' || this.remoteIP === '::ffff:127.0.0.1'))
                sigla = 'admin';
            if (sigla) {
                Statistics_1.Statistics.getStatisticsBySigla(this, sigla);
            }
            else {
                this.send404IfNotValue(false, 'Access denied ' + this.remoteIP);
            }
        }
        /**
         * RELOAD OPRAVNENI
         **/
        else if (this.query.permreload === 'true') {
            Permissions_1.Permissions.reloadPerms(this);
        }
        /**
         * PRIDANI NOVEHO OPRAVNENI
         **/
        else if (this.query.permcreate === 'true' && this.query.sigla) {
            Permissions_1.Permissions.addPerm(this);
        }
        /**
         * ALIVE
         **/
        else if ((this.requrl.indexOf(uriAlive)) > 0) {
            this.response.setHeader("Access-Control-Allow-Origin", "*");
            this.response.setHeader("Access-Control-Allow-Methods", "GET");
            this.response.setHeader("Access-Control-Allow-Header", "*");
            this.response.writeHead(200);
            this.response.end('ALIVE');
        }
        else {
            console.log("wrong query");
            this.send404IfNotValue(false);
        }
    };
    // nacteni metadat podle identifikatoru
    // pyta sa backendu na to co frontend este nema v cache
    // fetcha = identifikatory ktore sa dotazoval katalog v URL, ale v cache niesu
    // json = pole objektov zaznamov, ktore sa uz nasli v cache
    // http://www.obalkyknih.cz/api/books?books=[{%22bibinfo%22%3A{%22nbn%22%3A%22cnb001315197%22}%2C%22permalink%22%3A%22a%22}]&amp;review=1&amp;toc_full_text=1
    Server.prototype.metadata = function (s, fetcha, json, coverApi, tocThumbApi, tocPdfApi) {
        var sigla = s.sigla; //zrusit ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        var req = s.req;
        var db = s.db;
        var response = s.response;
        var query = s.query;
        var now = s.now;
        var resSimple = query.simple;
        testLog("46", "!!!![metadata] sigla: " + sigla + ", query:" + JSON.stringify(query) + ", now: " + now);
        if ((fetcha.length > 0) && (now > Statistics_1.Statistics.dateTimeout)) {
            // odlozeni pozadavku bokem (pripoji se rovno k odpovedi)
            var bibinfoOrig = new Array();
            for (var k in fetcha) {
                if (fetcha[k].bibinfo) {
                    bibinfoOrig[k] = {};
                    bibinfoOrig[k] = fetcha[k].bibinfo.bibinfo;
                    delete fetcha[k].bibinfo.bibinfo;
                }
            }
            // poskladani URL dotazu na BE
            var fetch = metaCollection == 'okcz' ? JSON.stringify(fetcha) : fetcha.join(',');
            fetch = encodeURIComponent(fetch);
            var url = 'http://' + urlMain + urlPart + urlMetadata + urlParams + fetch + '&amp;review=1&amp;toc_full_text=1';
            // console.log('request: ' + url); //debug
            // pole objektu fetcha prevedeno na pole retezcu; bude se parovat na odpoved bibinfo z BE
            var fetchaStr = [];
            if (metaCollection == 'okcz') {
                for (var i = 0; i < fetcha.length; i++) {
                    if (fetcha[i]) {
                        fetchaStr[i] = Helpers_1.Helpers.getSortedBibinfo(fetcha[i].bibinfo);
                    }
                }
            }
            Statistics_1.Statistics.addMetaFetches(sigla);
            request({ url: url, timeout: timeout }, function (error, res, body) {
                if (!error) {
                    // console.log(body);
                    try {
                        if (metaCollection == 'okcz') {
                            var jsonf = JSON.parse(body.substring(16, body.length - 3));
                        }
                        else {
                            var jsonf = JSON.parse(body);
                        }
                    }
                    catch (err) {
                        s.send404IfNotValue(false, 'JSON syntax error');
                        return;
                    }
                    // console.log(jsonf);
                    // projdi ziskane vysledky z BE serveru + uloz do DB unikatni kolekce
                    var fetchedAllready = [];
                    for (var i = 0; i < jsonf.length; i++) {
                        item = jsonf[i];
                        var recId = (item.ean13 || '#') + '-' + (item.oclc || '#') + '-' + (item.nbn || '#') + '-' + (item.ismn || '#');
                        delete item.permalink;
                        // Pridej do metadata kolekci pokud tam jeste neni.
                        // Kontroluje se protoze v jedinem back-end dotazu se muze vyskytnout stejny zaznam vice krat
                        // pokud se ptame napr. na parametr ISBN a podruhe na OCLC stejneho zaznamu.
                        if (!fetchedAllready[recId]) {
                            var id = new mongo.ObjectID();
                            id = id.toHexString();
                            fetchedAllready[recId] = id;
                            item._id = id;
                            db.collection(metaCollection).insert(item, { w: 1 }, function (err, result) {
                                if (err) {
                                    console.dir(err);
                                }
                            });
                        }
                        else {
                            item._id = fetchedAllready[recId];
                        }
                        if (!item.bibinfo || !fetchaStr.length) {
                            json.push(Helpers_1.Helpers.replaceUrl(item, resSimple));
                        }
                        else {
                            var pos = fetchaStr.indexOf(Helpers_1.Helpers.getSortedBibinfo(item.bibinfo));
                            if (pos >= 0) {
                                json[pos] = Helpers_1.Helpers.replaceUrl(item, resSimple, bibinfoOrig[pos]);
                                delete fetchaStr[pos];
                            }
                            else
                                json.push(Helpers_1.Helpers.replaceUrl(item, resSimple));
                        }
                    }
                }
                else {
                    if (error.code === 'ETIMEDOUT') {
                        Statistics_1.Statistics.dateTimeout = new Date().getTime() + timeOutDuration;
                        Statistics_1.Statistics.addTimeoutCount(sigla);
                        console.log('timeout : ' + Statistics_1.Statistics.dateTimeout);
                    }
                }
                if (coverApi) {
                    var item = json[0];
                    var coverUrl = Helpers_1.Helpers.getUrlByType(item, query.type);
                    if (s.sendPlaceholderIfNotValue(coverUrl)) {
                        return;
                    }
                    s.cover(s, coverUrl, coverApi, tocThumbApi);
                }
                else if (tocThumbApi) {
                    var item = json[0];
                    var tocThumbnailUrl = Helpers_1.Helpers.getUrlByType(item, 'toc_thumbnail');
                    if (s.sendPlaceholderIfNotValue(tocThumbnailUrl)) {
                        return;
                    }
                    //console.log(tocThumbnailUrl);
                    s.cover(s, coverUrl || tocThumbnailUrl, coverApi, tocThumbApi);
                }
                else if (tocPdfApi) {
                    var item = json[0];
                    var tocPdfUrl = item.toc_pdf_url;
                    if (s.sendPlaceholderIfNotValue(tocPdfUrl)) {
                        return;
                    }
                    s.toc(s, tocPdfUrl);
                }
                else {
                    var restmp = JSON.stringify(json, null, query.pretty ? ' ' : '');
                    response.end(restmp);
                }
            });
        }
        else {
            if (coverApi) {
                Statistics_1.Statistics.addCoverNotfound(sigla);
                s.sendPlaceholderIfNotValue(false);
            }
            else if (tocThumbApi) {
                Statistics_1.Statistics.addTocThumbnailNotfound(sigla);
                s.sendPlaceholderIfNotValue(false);
            }
            else if (tocPdfApi) {
                Statistics_1.Statistics.addTocPdfNotfound(sigla);
                s.sendPlaceholderIfNotValue(false);
            }
            else {
                var restmp = JSON.stringify(json, null, query.pretty ? ' ' : '');
                response.end(restmp);
            }
        }
    };
    // ziskani / stazeni obalky podle url souborove cesty
    Server.prototype.cover = function (s, coverUrl, coverApi, tocThumbApi) {
        var sigla = s.sigla;
        var req = s.req;
        var db = s.db;
        var response = s.response;
        var query = s.query;
        var now = s.now;
        var remoteIP = s.remoteIP;
        var referer = s.referer;
        var timestamp = s.timestamp;
        var etag = s.etag;
        testLog("43", "!!!![metadata] sigla: " + sigla + ", query:" + JSON.stringify(query) + ", now: " + now + ", remoteIP:" + remoteIP + ", referer: " + referer + ", timestamp: " + timestamp + ", etag: " + etag);
        // var coverUrl=requrl.split('?')[0];
        if (query.keywords) {
            var keywords = query.keywords.trim().replace(/\s+|\t+/g, ' ').split(' ');
        }
        else {
            var keywords = [];
        }
        db.collection('cover').findOne({ url: coverUrl }, function (err, item) {
            // typ dokumentu, ktery nacitame (cover, nebo toc nahled)
            var coverType = 'cover';
            if (tocThumbApi || (coverUrl.indexOf(urlTocFile)) > 0)
                coverType = 'toc';
            if ((item !== null) && (!item.notfound)) {
                // nastav etag
                if (coverType == 'cover') {
                    response.setHeader('Etag', item._id);
                    etags[item._id] = null;
                }
                else if (coverType == 'toc') {
                    response.setHeader('Etag', 'toct-' + md5(coverUrl));
                    etags['toct-' + md5(coverUrl)] = null;
                }
                response.writeHead(200, { 'Content-Type': 'image/jpeg', 'Etag': 'toct-' + md5(coverUrl) });
                response.end(item.x.buffer);
                db.collection('logs').insert({ sigla: sigla, ip: remoteIP, referer: referer, op: coverUrl, state: 'local', keywords: keywords, timestamp: timestamp }, { w: 0 });
            }
            else if (item && (item.notfound > now)) {
                if (coverApi || tocThumbApi) {
                    s.sendPlaceholderIfNotValue(false);
                }
                else {
                    s.send404IfNotValue(false);
                }
            }
            else if (now > Statistics_1.Statistics.dateTimeout) {
                var options = {
                    hostname: urlMain,
                    path: coverUrl
                };
                var request = http.request(options, function (res) {
                    if (!item) {
                        var id = new mongo.ObjectID();
                    }
                    else {
                        var id = item._id;
                    }
                    // zaznac do statistik zadost o stazeni obalkyl; bez ohledu na to, jestli se povede
                    if (coverType == 'cover') {
                        Statistics_1.Statistics.addCoverFetches(sigla);
                        etag = id.toHexString();
                    }
                    else if (coverType == 'toc') {
                        Statistics_1.Statistics.addTocThumbnailFetches(sigla);
                        etag = 'toct-' + md5(coverUrl);
                    }
                    etags[etag] = null;
                    response.setHeader('Etag', etag);
                    if (res.statusCode !== 200) {
                        // obalka nebyla stazena; poznac do statistik
                        if (coverType == 'cover') {
                            Statistics_1.Statistics.addCoverNotfound(sigla);
                        }
                        else if (coverType == 'toc') {
                            Statistics_1.Statistics.addTocThumbnailNotfound(sigla);
                        }
                        if (!item) {
                            db.collection('cover').insert({ notfound: now + timeNotfound, _id: id, url: coverUrl }, { w: 1 }, function (err, result) {
                                if (err) {
                                    console.dir(err);
                                }
                            });
                        }
                        else {
                            db.collection('cover').update({ _id: id }, { notfound: now + timeNotfound, url: coverUrl }, { w: 1 }, function (err, result) {
                                if (err) {
                                    console.dir(err);
                                }
                            });
                        }
                        if (coverApi || tocThumbApi) {
                            s.sendPlaceholderIfNotValue(false);
                        }
                        else {
                            s.send404IfNotValue(false);
                        }
                        return;
                    }
                    response.writeHead(200, { 'Content-Type': 'image/jpeg', 'Etag': etag });
                    //var cover='';
                    var data = [];
                    res.on('error', function (e) {
                        console.log(e);
                    });
                    res.on('data', function (chunk) {
                        data.push(chunk);
                        response.write(chunk);
                    }); //.pipe(response);
                    res.on('end', function () {
                        response.end();
                        var cover = new Buffer(data.reduce(function (prev, current) {
                            return prev.concat(Array.prototype.slice.call(current));
                        }, []));
                        var binary = new mongo.Binary(cover);
                        db.collection('cover').insert({ x: binary, _id: id, url: coverUrl }, { w: 1 }, function (err, result) {
                            if (err) {
                                console.dir(err);
                            }
                        });
                        db.collection('logs').insert({ sigla: sigla, ip: remoteIP, referer: referer, op: coverUrl, state: 'fetch', keywords: keywords, timestamp: timestamp }, { w: 0 });
                    });
                });
                request.setTimeout(timeout, function () {
                    Statistics_1.Statistics.dateTimeout = new Date().getTime() + timeOutDuration;
                    Statistics_1.Statistics.addTimeoutCount(sigla);
                    console.log('timeout : ' + Statistics_1.Statistics.dateTimeout);
                    request.abort();
                    response.end();
                });
                request.on('error', function (err) {
                    if (err.code === "ECONNRESET") {
                        console.log("Timeout occurs");
                    }
                });
                request.end();
            }
            else {
                // console.log('cover404');
                if (coverApi || tocThumbApi) {
                    s.sendPlaceholderIfNotValue(false);
                }
                else {
                    s.send404IfNotValue(false);
                }
            }
        });
    };
    // poskytnuti souboru s TOC
    Server.prototype.toc = function (s, reqUrl) {
        var sigla = s.sigla;
        var req = s.req;
        var db = s.db;
        var response = s.response;
        var remoteIP = s.remoteIP;
        var referer = s.referer;
        var timestamp = s.timestamp;
        testLog("43", "!!!![metadata] sigla: " + sigla + ", req: " + req + ", db: " + db + ", response: " + response + ", remoteIP:" + remoteIP + ", referer: " + referer + ", timestamp: " + timestamp);
        reqUrl = reqUrl.replace('http://' + urlMain, '');
        var tocPdfUrlSegments = reqUrl.split('/');
        var tocFileName = tocPdfUrlSegments[tocPdfUrlSegments.length - 2];
        var tocExtension = tocPdfUrlSegments[tocPdfUrlSegments.length - 1];
        if (!tocFileName) {
            s.send404IfNotValue(false);
        }
        var mimeType = 'application/' + (tocExtension || 'pdf');
        var tocFileEncapDir = Math.ceil((parseInt(tocFileName) + 1) / 10000) * 10000;
        var tocFilePath = tocFileDir + tocFileEncapDir + '/' + tocFileName + '.' + (tocExtension || 'pdf');
        fs.exists(tocFilePath, function (exists) {
            if (exists) {
                var tocFileStat = fs.statSync(tocFilePath);
                console.log('toc ' + tocExtension + ': ' + tocFilePath);
                response.writeHead(200, {
                    'Content-Type': mimeType,
                    'Content-Length': tocFileStat.size,
                    'Etag': 'tocp-' + md5(tocFilePath)
                });
                etags['tocp-' + md5(tocFilePath)] = null;
                var readStream = fs.createReadStream(tocFilePath);
                readStream.pipe(response);
                db.collection('logs').insert({ sigla: sigla, ip: remoteIP, referer: referer, op: urlTocFile + '/' + tocFileName + uriPartTocPdf, state: 'local', keywords: [], timestamp: timestamp }, { w: 0 });
            }
            else {
                Statistics_1.Statistics.addTocPdfNotfound(sigla);
                s.send404IfNotValue(false);
            }
        });
    };
    /* VLASTNE -------------------------------------------------------------------------------------------------- */
    Server.prototype.isRequestValid = function (sigla, validate_sigla, validate_parameters, validate_query_book_id_AND_query_id, validate_query_id) {
        if (validate_parameters === void 0) { validate_parameters = false; }
        if (validate_query_book_id_AND_query_id === void 0) { validate_query_book_id_AND_query_id = false; }
        if (validate_query_id === void 0) { validate_query_id = false; }
        if (validate_sigla && !sigla) {
            var ipv4 = this.remoteIP;
            if (ipv4.indexOf('::ffff:') !== -1)
                ipv4 = ipv4.substring(7);
            this.send404IfNotValue(false, 'Unknown referer. You need to sign up at http://www.obalkyknih.cz and provide your catalog URL; Referer: ' + this.referer + '  IP: ' + ipv4);
            return false;
        }
        if (validate_parameters && !this.query.isbn && !this.query.nbn && !this.query.ismn && !this.query.oclc && !this.query.ean && !this.query.multi && !this.query.auth_id && !this.query.uuid) {
            console.log('Param missing');
            this.send404IfNotValue(false);
            return false;
        }
        if (validate_query_book_id_AND_query_id && (!sigla || !this.query.book_id || !this.query.id)) {
            console.log('add review denied ' + this.remoteIP);
            this.send404IfNotValue(false, 'Add review denied' + (!this.query.book_id ? ' (book_id missing)' : '') + (!this.query.id ? ' (ID param missing)' : ''));
            return false;
        }
        if (validate_query_id && (!sigla || !this.query.id)) {
            console.log('del review denied ' + this.remoteIP);
            this.send404IfNotValue(false, 'Del review denied' + (!this.query.id ? ' (id missing)' : ''));
            return false;
        }
        return true;
    };
    Server.prototype.getResult = function () {
        // parse params
        if (this.query.isbn || this.query.ean) {
            var isbn = this.query.isbn ? this.query.isbn.split(' ')[0] : this.query.ean.split(' ')[0];
            var value = toEan(isbn);
            var sel = { $or: [{ ean: value }, { ean_other: value }] };
            var bib = { isbn: value };
            return (!value) ? undefined : { bib: bib, sel: sel };
        }
        else if (this.query.nbn) {
            var value = this.query.nbn;
            var sel = bib = { nbn: value };
            return (!value) ? undefined : { bib: bib, sel: sel };
        }
        else if (this.query.ismn) {
            var value = this.query.ismn.replace('-', '');
            var sel = bib = { ismn: value };
            return (!value) ? undefined : { bib: bib, sel: sel };
        }
        else if (this.query.oclc) {
            var value = this.query.oclc;
            var sel = bib = { oclc: value };
            return (!value) ? undefined : { bib: bib, sel: sel };
        }
        else if (this.query.multi) {
            var bib = {};
            var sel = { $or: [] };
            try {
                this.query.multi = decodeURIComponent(this.query.multi);
                var multis = JSON.parse(decodeURIComponent(this.query.multi));
            }
            catch (err) {
                this.response.writeHead(404);
                this.response.end('Check query syntax');
                return;
            }
            if (multis.isbn || multis.ean) {
                var isbn = multis.isbn ? multis.isbn.split(' ')[0] : multis.ean.split(' ')[0];
                var value = toEan(isbn);
                sel.$or.push({ ean: value });
                sel.$or.push({ ean_other: value });
                bib.isbn = value;
            }
            if (multis.ismn) {
                var ismn = multis.ismn;
                ismn = ismn.replace(/\-/g, '');
                sel.$or.push({ ismn: ismn });
                bib.ismn = ismn;
            }
            if (multis.oclc) {
                sel.$or.push({ oclc: multis.oclc });
                bib.oclc = multis.oclc;
            }
            if (multis.nbn) {
                sel.$or.push({ nbn: multis.nbn });
                bib.nbn = multis.nbn;
            }
            // parsovani identifikatoru vicesvazkoveho dila a periodika (parse_note se pouziva pokud knihovni system nema data rok/rocnik/cislo/cislo casti/nazev casti oddelene)
            if (multis.part_note) {
                var parts = partParser.parse(multis.part_note);
                if (parts.year)
                    multis.part_year = parts.year;
                if (parts.volume)
                    multis.part_volume = parts.volume;
                if (parts.part)
                    multis.part_no = parts.part;
                if (parts.part && !parts.year && !parts.volume)
                    multis.part_name = parts.part;
            }
            if (Helpers_1.Helpers.partValidation(multis)) {
                // normalizace
                if (multis.part_year)
                    multis.part_year = partParser.normalizeYear(multis.part_year);
                if (multis.part_volume)
                    multis.part_volume = partParser.normalizeVolume(multis.part_volume);
                if (multis.part_no)
                    multis.part_no = partParser.normalizePart(multis.part_no);
                if (multis.part_name)
                    multis.part_name = partParser.normalizePart(multis.part_name);
                // normalizace spatne zduplikovaneho roku, rocniku, nebo cisla v pozadavku
                if (multis.part_year && multis.part_volume && multis.part_year == multis.part_volume) {
                    if (multis.part_year.length == 4)
                        delete multis.part_volume;
                    else
                        delete multis.part_year;
                }
                if (multis.part_year && multis.part_no && multis.part_year == multis.no) {
                    if (multis.part_year.length == 4)
                        delete multis.part_no;
                }
                // dotaz na periodikum
                if (multis.part_year || multis.part_volume) {
                    if (multis.part_year) {
                        bib.part_year = multis.part_year;
                    }
                    if (multis.part_volume) {
                        bib.part_volume = multis.part_volume;
                    }
                    if (multis.part_no) {
                        bib.part_no = multis.part_no;
                    }
                }
                // dotaz na vicesvazkovou monografii pomoci part_no (245n) a zaroven part_name (245p)
                else if (multis.part_no && multis.part_name) {
                    bib.part_no = multis.part_no;
                    bib.part_name = multis.part_name;
                }
                // dotaz na vicesvazkovou monografii pouze pomoci part_no (245n)
                else if (multis.part_no) {
                    bib.part_no = multis.part_no;
                }
                // dotaz na vicesvazkovou monografii pouze pomoci part_name (245p)
                else if (multis.part_name) {
                    bib.part_name = multis.part_name;
                }
            }
            return (sel.$or.length <= 0) ? undefined : { bib: bib, sel: sel };
        }
        else {
            return undefined;
        }
    };
    //ak posle vrati true, ak neposle vrati false
    Server.prototype.sendPlaceholderIfNotValue = function (value) {
        if (!value) {
            console.log("identifier " + this.requrl);
            this.response.writeHead(200, { 'Content-Type': 'image/gif' });
            this.response.end(Server.placeholder);
            return true;
        }
        else {
            return false;
        }
    };
    //ak posle vrati true, ak neposle vrati false
    Server.prototype.send404IfNotValue = function (value, message) {
        if (message === void 0) { message = undefined; }
        if (!value) {
            this.response.writeHead(404);
            if (message)
                this.response.end(message);
            else
                this.response.end();
            return true;
        }
        else {
            return false;
        }
    };
    Server.prototype.getSortedItemsFromItemsRaw = function (items_raw) {
        /* Serazeni podle part_root */
        var items_root = [], items_common = [], items_root_bare = [], items_common_bare = [];
        for (var i = 0; i < items_raw.length; i++) {
            var tmp_part_root = items_raw[i].part_root || '1';
            var tmp_flag_bare_record = items_raw[i].flag_bare_record || '1';
            // prioritu maji uzitecne casti s part_root = 1
            if (tmp_part_root == '1' && tmp_flag_bare_record == '0')
                items_root.push(items_raw[i]);
            // pote zbytek part_root = 1
            else if (tmp_part_root == '1')
                items_root_bare.push(items_raw[i]);
            // dale normalni uzitecne zaznamy
            else if (tmp_flag_bare_record == '1')
                items_common.push(items_raw[i]);
            // a na konci pole budou ty nepotrebne
            else
                items_common_bare.push(items_raw[i]);
        }
        return items_root.concat(items_root_bare).concat(items_common).concat(items_common_bare);
    };
    Server.prototype.getItemInfoFromItem = function (item) {
        var itemInfo = {};
        itemInfo.item = item;
        itemInfo.ean13 = item.ean13;
        itemInfo.ean13_other = item.ean13_other;
        itemInfo.nbn = item.nbn;
        itemInfo.ismn = item.ismn;
        itemInfo.oclc = item.oclc;
        itemInfo.uuid = item.uuid;
        itemInfo.part_year = item.part_year;
        itemInfo.part_volume = item.part_volume;
        itemInfo.part_no = item.part_no;
        itemInfo.part_name = item.part_name;
        itemInfo.part_root = item.part_root || '1';
        itemInfo.part_ean13_standalone = item.part_ean13_standalone || '0';
        itemInfo.part_nbn_standalone = item.part_nbn_standalone || '0';
        itemInfo.part_ismn_standalone = item.part_ismn_standalone || '0';
        itemInfo.part_oclc_standalone = item.part_oclc_standalone || '0';
        return itemInfo;
    };
    Server.prototype.isGoodItemInfoForBibInfo = function (itemInfo, bibinfo) {
        return (
        // periodikum podle roku a cisla
        (itemInfo.part_year && itemInfo.part_no && bibinfo.part_year && bibinfo.part_no && itemInfo.part_year == bibinfo.part_year && itemInfo.part_no == bibinfo.part_no) ||
            // periodikum podle rocniku a cisla
            (itemInfo.part_volume && itemInfo.part_no && bibinfo.part_volume && bibinfo.part_no && itemInfo.part_volume == bibinfo.part_volume && itemInfo.part_no == bibinfo.part_no) ||
            // periodikum podle roku a rocniku
            ((itemInfo.part_year || itemInfo.part_volume) && !itemInfo.part_no && (bibinfo.part_year || bibinfo.part_volume) && ((itemInfo.part_year == bibinfo.part_year && itemInfo.part_year) || (itemInfo.part_volume == bibinfo.part_volume && itemInfo.part_volume))) ||
            // monografie podle cisla casti
            (itemInfo.part_no && bibinfo.part_no && !bibinfo.part_year && !bibinfo.part_volume && itemInfo.part_no == bibinfo.part_no) ||
            // monografie podle nazvu casti
            (itemInfo.part_name && bibinfo.part_name && !bibinfo.part_year && !bibinfo.part_volume && itemInfo.part_name == bibinfo.part_name) ||
            // souborny zaznam, nebo cast monografie bez dotazu na konkretni cast
            (!bibinfo.part_no && !bibinfo.part_name && !bibinfo.part_year && !bibinfo.part_volume) ||
            // souborny zaznam, s dotazem na cast monografie bez dotazu na konkretni cast
            (!bibinfo.part_year && !bibinfo.part_volume && !itemInfo.part_no && !itemInfo.part_name));
    };
    Server.prototype.itemFound = function (itemInfo, bibinfo, j) {
        if (j == 0 && bibinfo.isbn) {
            // ISBN
            var isbnBib = bibinfo.isbn.split(' ')[0];
            isbnBib = toEan(isbnBib);
            if (!isbnBib || !itemInfo.ean13)
                return false;
            if (isbnBib != itemInfo.ean13)
                return false;
            if (itemInfo.part_root == '0' && itemInfo.part_ean13_standalone == '0' && !(bibinfo.part_no || bibinfo.part_name || bibinfo.part_year || bibinfo.part_volume))
                return false;
            return true;
        }
        else if (j == 1 && bibinfo.nbn) {
            // NBN
            if (!bibinfo.nbn || !itemInfo.nbn)
                return false;
            if (bibinfo.nbn != itemInfo.nbn)
                return false;
            if (itemInfo.part_root == '0' && itemInfo.part_nbn_standalone == '0' && !(bibinfo.part_no || bibinfo.part_name || bibinfo.part_year || bibinfo.part_volume))
                return false;
            return true;
        }
        else if (j == 2 && bibinfo.oclc) {
            // OCLC
            if (!bibinfo.oclc || !itemInfo.oclc)
                return false;
            if (bibinfo.oclc != itemInfo.oclc)
                return false;
            if (itemInfo.part_root == '0' && itemInfo.part_oclc_standalone == '0' && !(bibinfo.part_no || bibinfo.part_name || bibinfo.part_year || bibinfo.part_volume))
                return false;
            return true;
        }
        else if (j == 3 && bibinfo.uuid) {
            // UUID
            if (!bibinfo.uuid.length || !itemInfo.uuid)
                return false;
            return (itemInfo.uuid.indexOf(bibinfo.uuid) > -1) ? true : false;
        }
        else if (j == 4 && bibinfo.ismn) {
            // ISMN
            if (!bibinfo.ismn || !itemInfo.ismn)
                return false;
            bibinfo.ismn = bibinfo.ismn;
            if (bibinfo.ismn != itemInfo.ismn)
                return false;
            if (itemInfo.part_root == '0' && itemInfo.part_ismn_standalone == '0' && !(bibinfo.part_no || bibinfo.part_name || bibinfo.part_year || bibinfo.part_volume))
                return false;
            return true;
        }
        else if (j == 5 && bibinfo.isbn) {
            // OTHER ISBN
            var isbnBib = bibinfo.isbn.split(' ')[0];
            isbnBib = toEan(isbnBib);
            var ean_other_length = 0;
            if (itemInfo.ean13_other)
                ean_other_length = itemInfo.ean13_other.length;
            for (var i = 0; i < ean_other_length; i++) {
                var item = itemInfo.ean13_other[i];
                if (!isbnBib || !item)
                    return false;
                if (isbnBib != item)
                    return false;
                if (itemInfo.part_root == '0' && itemInfo.part_ean13_standalone == '0' && !(bibinfo.part_no || bibinfo.part_name || bibinfo.part_year || bibinfo.part_volume))
                    return false;
                return true;
            }
        }
    };
    Server.placeholderData = [
        0x47, 0x49, 0x46, 0x38, 0x39, 0x61, 0x01, 0x00, 0x01, 0x00, 0x80, 0x00, 0x00, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x21, 0xF9, 0x04, 0x01, 0x0A, 0x00, 0x01, 0x00, 0x2c, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x01, 0x00, 0x00, 0x02, 0x02, 0x4C, 0x01, 0x00, 0x3B
    ];
    Server.placeholder = new Buffer(Server.placeholderData);
    return Server;
}());
module.exports = {
    server: server,
    getPerms: Permissions_1.Permissions.getPerms
};
function testLog(color, message) {
    console.log('\x1b[' + color + 'm', message, '\x1b[0m'); //debug
}
